//! Phase 3: Base system installation steps.
//!
//! Steps 7-9: Extract tarball, generate fstab, setup chroot.

use super::{CheckResult, Step, StepResult};
use crate::qemu::Console;
use anyhow::Result;
use std::time::{Duration, Instant};

/// Step 7: Extract stage3 tarball
pub struct ExtractTarball;

impl Step for ExtractTarball {
    fn num(&self) -> usize { 7 }
    fn name(&self) -> &str { "Extract Stage3 Tarball" }

    fn execute(&self, console: &mut Console) -> Result<StepResult> {
        let start = Instant::now();
        let mut result = StepResult::new(self.num(), self.name());

        // Check if tarball exists (mounted from ISO or copied)
        let check_tarball = console.exec(
            "ls -la /stage3.tar.xz 2>/dev/null || ls -la /mnt/cdrom/stage3.tar.xz 2>/dev/null",
            Duration::from_secs(5),
        )?;

        let tarball_path = if check_tarball.output.contains("/stage3.tar.xz") {
            "/stage3.tar.xz"
        } else if check_tarball.output.contains("/mnt/cdrom/stage3.tar.xz") {
            "/mnt/cdrom/stage3.tar.xz"
        } else {
            result.add_check(
                "Stage3 tarball found",
                CheckResult::Fail {
                    expected: "stage3.tar.xz in / or /mnt/cdrom".to_string(),
                    actual: "Tarball not found".to_string(),
                },
            );
            result.fail("Ensure stage3.tar.xz is included in the ISO or copied to the live system");
            return Ok(result);
        };

        result.add_check(
            "Stage3 tarball found",
            CheckResult::Pass(format!("Found at {}", tarball_path)),
        );

        // Extract tarball
        let extract = console.exec(
            &format!("tar xf {} -C /mnt", tarball_path),
            Duration::from_secs(300), // 5 minutes for extraction
        )?;

        if extract.success() {
            result.add_check(
                "Tarball extracted",
                CheckResult::Pass("Extracted to /mnt".to_string()),
            );
        } else {
            result.add_check(
                "Tarball extracted",
                CheckResult::Fail {
                    expected: "tar exit 0".to_string(),
                    actual: format!("exit {}: {}", extract.exit_code, extract.output),
                },
            );
            return Ok(result);
        }

        // Verify essential directories exist
        let verify = console.exec(
            "ls /mnt/bin /mnt/usr /mnt/etc 2>/dev/null && echo VERIFY_OK",
            Duration::from_secs(5),
        )?;

        if verify.output.contains("VERIFY_OK") {
            result.add_check(
                "Base system verified",
                CheckResult::Pass("/bin, /usr, /etc exist".to_string()),
            );
        } else {
            result.add_check(
                "Base system verified",
                CheckResult::Fail {
                    expected: "Essential directories".to_string(),
                    actual: "Missing directories".to_string(),
                },
            );
        }

        result.duration = start.elapsed();
        Ok(result)
    }
}

/// Step 8: Generate /etc/fstab
pub struct GenerateFstab;

impl Step for GenerateFstab {
    fn num(&self) -> usize { 8 }
    fn name(&self) -> &str { "Generate fstab" }

    fn execute(&self, console: &mut Console) -> Result<StepResult> {
        let start = Instant::now();
        let mut result = StepResult::new(self.num(), self.name());

        // Get UUIDs for partitions
        let uuid_root = console.exec(
            "blkid -s UUID -o value /dev/vda2",
            Duration::from_secs(5),
        )?;
        let uuid_boot = console.exec(
            "blkid -s UUID -o value /dev/vda1",
            Duration::from_secs(5),
        )?;

        let root_uuid = uuid_root.output.trim();
        let boot_uuid = uuid_boot.output.trim();

        if root_uuid.is_empty() || boot_uuid.is_empty() {
            result.add_check(
                "UUIDs retrieved",
                CheckResult::Fail {
                    expected: "UUIDs for both partitions".to_string(),
                    actual: format!("root={}, boot={}", root_uuid, boot_uuid),
                },
            );
            result.fail("Run blkid to check partition UUIDs");
            return Ok(result);
        }

        result.add_check(
            "UUIDs retrieved",
            CheckResult::Pass(format!("root={}, boot={}", root_uuid, boot_uuid)),
        );

        // Generate fstab content
        let fstab = format!(
            "# /etc/fstab - generated by install-tests
# <file system>  <mount point>  <type>  <options>  <dump>  <pass>
UUID={}  /      ext4   defaults  0  1
UUID={}  /boot  vfat   defaults  0  2
",
            root_uuid, boot_uuid
        );

        // Write fstab
        console.write_file("/mnt/etc/fstab", &fstab)?;

        // Verify fstab was written
        let verify = console.exec("cat /mnt/etc/fstab", Duration::from_secs(5))?;

        if verify.output.contains(root_uuid) && verify.output.contains(boot_uuid) {
            result.add_check(
                "fstab written",
                CheckResult::Pass("Contains correct UUIDs".to_string()),
            );
        } else {
            result.add_check(
                "fstab written",
                CheckResult::Fail {
                    expected: "UUIDs in fstab".to_string(),
                    actual: verify.output.clone(),
                },
            );
        }

        result.duration = start.elapsed();
        Ok(result)
    }
}

/// Step 9: Setup chroot environment
pub struct SetupChroot;

impl Step for SetupChroot {
    fn num(&self) -> usize { 9 }
    fn name(&self) -> &str { "Setup Chroot" }

    fn execute(&self, console: &mut Console) -> Result<StepResult> {
        let start = Instant::now();
        let mut result = StepResult::new(self.num(), self.name());

        // Enter chroot (this sets up bind mounts)
        match console.enter_chroot("/mnt") {
            Ok(()) => {
                result.add_check(
                    "Chroot entered",
                    CheckResult::Pass("Bind mounts created".to_string()),
                );
            }
            Err(e) => {
                result.add_check(
                    "Chroot entered",
                    CheckResult::Fail {
                        expected: "Successful chroot setup".to_string(),
                        actual: e.to_string(),
                    },
                );
                result.fail("Check mount points and /mnt contents");
                return Ok(result);
            }
        }

        // Verify we can run commands in chroot
        let verify = console.exec_chroot("echo CHROOT_OK", Duration::from_secs(5))?;

        if verify.output.contains("CHROOT_OK") {
            result.add_check(
                "Chroot functional",
                CheckResult::Pass("Commands execute in chroot".to_string()),
            );
        } else {
            result.add_check(
                "Chroot functional",
                CheckResult::Fail {
                    expected: "CHROOT_OK".to_string(),
                    actual: verify.output.clone(),
                },
            );
        }

        result.duration = start.elapsed();
        Ok(result)
    }
}
